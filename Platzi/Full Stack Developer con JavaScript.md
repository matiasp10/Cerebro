#### ¿Cómo renderizamos el componente principal de nuestra aplicación con React 17?

a -`ReactDOM.createComponent()`

b - `React.render()`

c - `React.createElement()`

d - `ReactDOM.render()`

La respuesta correcta es: d) ReactDOM.render()

ReactDOM.render() es la función que se utiliza para renderizar un componente de React en un elemento del DOM. Esta función toma dos argumentos: el componente de React que quieres renderizar y el elemento del DOM en el que quieres renderizar el componente.

Por ejemplo:

Copy code

`ReactDOM.render(<MiComponente />, document.getElementById('root'));`

En este ejemplo, estamos renderizando el componente `MiComponente` en el elemento del DOM con id 'root'.

#### ¿Qué sentencia debemos agregar a la sentencia "DELETE" a manera de red de protección?

a - WHERE

b - NONE

La respuesta correcta es: a) WHERE

La cláusula WHERE se utiliza en la sentencia DELETE de SQL para especificar qué filas se deben eliminar de una tabla. Si no se incluye la cláusula WHERE en la sentencia DELETE, se eliminarán todas las filas de la tabla. Por lo tanto, es importante utilizar la cláusula WHERE para especificar qué filas se deben eliminar y evitar eliminar accidentalmente todos los datos de la tabla.

Por ejemplo:

`DELETE FROM tabla_name WHERE condition;`

En este ejemplo, se eliminarán las filas de la tabla 'tabla_name' que cumplan con la condición especificada en la cláusula WHERE.

¿En qué fase de un proyecto se utiliza más fuertemente el lenguaje DML? a Al modificar la estructura de la BD b En el día a día c Al inicio d Casi nunca e Al final

La respuesta correcta es: b) En el día a día

El lenguaje DML (Data Manipulation Language) se utiliza para manipular datos en una base de datos. Esto incluye operaciones como insertar, actualizar y eliminar datos. Se utiliza en todas las fases de un proyecto, pero se utiliza más fuertemente en el día a día del proyecto, ya que estas operaciones son las que se realizan con más frecuencia durante el uso normal de la base de datos.

Al modificar la estructura de la base de datos, se utilizan otras sentencias, como las sentencias DDL (Data Definition Language), que se utilizan para crear, modificar y eliminar tablas y otros objetos de base de datos.

Es importante tener en cuenta que el lenguaje DML no se utiliza casi nunca al inicio o al final de un proyecto. En lugar de eso, se utilizan para realizar operaciones de manipulación de datos durante el uso normal de la base de datos.

#### ¿La terminal ideal para usar Git en Windows es?

a - Git Bash o una _terminal_ derivada de Linux

b - Github GUI

c - Powershell

d - MS-DOS

e - Un cliente visual de Git

La respuesta correcta es: a) Git Bash o una terminal derivada de Linux

Git Bash es una terminal gratuita y de código abierto que se incluye con Git para Windows. Proporciona un entorno de línea de comandos que es compatible con la mayoría de los comandos de Git y también incluye algunas herramientas de Unix como ssh, scp y rsync. Git Bash es una excelente opción para usar Git en Windows ya que es fácil de instalar y proporciona un entorno de línea de comandos completo.

Otras opciones populares para usar Git en Windows incluyen terminales derivadas de Linux como Cygwin o MinGW, que proporcionan un entorno de línea de comandos similar a Linux en Windows.

Github GUI es un cliente visual de Git que se puede utilizar para realizar operaciones de Git de forma gráfica en lugar de utilizar la línea de comandos. Aunque es una opción válida para usar Git en Windows, la terminal es una opción más versátil y poderosa que proporciona acceso a todas las funciones de Git.

Powershell y MS-DOS son ambas opciones de línea de comandos en Windows, pero no son ideales para usar Git ya que no proporcionan todas las funciones necesarias para trabajar con Git de forma eficiente.

#### ¿Qué es una aplicación web progresiva (PWA)?

a - Son aplicaciones web que permiten incorporar comportamientos de una app nativa.

b - Son aplicaciones móviles que permiten incorporar comportamientos de una aplicación web.

c - Son aplicaciones web que se actualizan constante y progresivamente.

d - Son aplicaciones móviles que se actualizan con la frecuencia y facilidad de una app web.

La respuesta correcta es: a) Son aplicaciones web que permiten incorporar comportamientos de una app nativa.

Las aplicaciones web progresivas (PWA, por sus siglas en inglés) son aplicaciones web que se comportan como aplicaciones nativas en dispositivos móviles. Esto significa que pueden ser instaladas en el teléfono del usuario y se ejecutan en un marco de aplicación, como cualquier otra aplicación móvil. Además, las PWA tienen acceso a características nativas del dispositivo, como la cámara, el GPS y las notificaciones push, lo que les permite ofrecer una experiencia de usuario similar a la de una aplicación nativa.

Las PWA son una opción atractiva para los desarrolladores ya que permiten crear aplicaciones móviles que se pueden utilizar en cualquier navegador web y no requieren distribución a través de la App Store o Google Play. Además, las PWA se pueden actualizar de forma transparente para el usuario, lo que las hace más fáciles de mantener que las aplicaciones nativas.

#### Para una entrevista técnica es importante:

a - Pensar en varias cosas de la vida sin importar que te distraigan.

b - Estar cómodo(a), tener listo el ambiente de desarrollo y estar concentrado(a).

c - Desconocer tu propio entorno de desarrollo para que posterguen la entrevista.

d - Estar con tu mejor outfit sin importar qué tan incómodo pueda ser.

La respuesta correcta es: b) Estar cómodo(a), tener listo el ambiente de desarrollo y estar concentrado(a).

Es importante prepararse adecuadamente para una entrevista técnica para poder demostrar tus habilidades y conocimientos de forma efectiva. Esto incluye estar cómodo(a) y tener tu entorno de desarrollo listo y funcionando correctamente. También es importante estar concentrado(a) y enfocado(a) durante la entrevista para poder responder a las preguntas y realizar las tareas técnicas de forma efectiva.

No es recomendable distraerse pensando en otras cosas durante la entrevista ni descuidar tu apariencia o tu entorno de trabajo. Es importante mostrar tu mejor aspecto y estar preparado(a) para demostrar tus habilidades técnicas.

#### La metodología que nos sugiere tener una sintaxis donde se pueda diferenciar el bloque de los elementos y de los modificadores es:

a - SMACSS

b - OOCSS

c - BEM

d - Ninguna de las anteriores

La respuesta correcta es: c) BEM

BEM es una metodología de diseño y estilo para desarrollo web que se centra en la claridad y la mantenibilidad del código. La metodología BEM sugiere una sintaxis de nomenclatura de clases que permite diferenciar claramente entre bloques (elementos independientes y reutilizables), elementos (partes de un bloque) y modificadores (estilos que modifican el comportamiento o el aspecto de un bloque o elemento).

La sintaxis BEM se escribe en minúsculas y utiliza guiones bajos y guiones para separar los diferentes componentes de la clase. Por ejemplo, un bloque se escribiría como `.block`, un elemento se escribiría como `.block__element` y un modificador se escribiría como `.block--modifier`.

BEM es una metodología popular para desarrollar proyectos web grandes y complejos, ya que permite crear un código claro y fácilmente mantenible. Sin embargo, no es la única opción disponible y otras metodologías como SMACSS y OOCSS también son populares.

#### ¿Qué extensión nos permite actualizar los cambios de nuestra página web de manera automática?

a - Power mode

b - Liver Server

c - Auto Rename Tag

d - Prettier

La respuesta correcta es: b) Live Server

Live Server es una extensión de Visual Studio Code que permite actualizar los cambios de una página web de manera automática. Cuando se utiliza Live Server, cada vez que se guardan cambios en el código de la página web, la página se vuelve a cargar automáticamente en el navegador para mostrar los cambios. Esto puede ser muy útil durante el desarrollo y permite ver los cambios en tiempo real sin tener que recargar manualmente la página.

Power mode, Auto Rename Tag y Prettier son otras extensiones de Visual Studio Code, pero no tienen nada que ver con la actualización automática de páginas web. Power mode añade efectos visuales al editor de código cuando se escribe, Auto Rename Tag permite cambiar el nombre de etiquetas HTML de forma automática y Prettier es un formateador de código que ayuda a mantener un estilo consistente en el código.

#### ¿Cuál es la manera de  correcta de declarar una ruta que reciba un parámetro llamado productId?

a - app.get('/products/*productId',  ...)

b - app.get(’/products/``<productid>``’, …)

c - app.get('/products/:productId',  ...)

La respuesta correcta es: c) app.get('/products/:productId', ...)

En Express, la forma correcta de declarar una ruta que recibe un parámetro es utilizando el símbolo ':' seguido del nombre del parámetro. Por ejemplo:

Copy code

`app.get('/products/:productId', function(req, res) {   // El parámetro productId está disponible en req.params.productId });`

En este ejemplo, estamos declarando una ruta que se activa cuando se hace una solicitud GET a '/products/:productId'. El parámetro 'productId' estará disponible en el objeto `req.params` y podrá ser utilizado para recuperar el valor específico enviado por el usuario.

Las otras opciones no son válidas para declarar parámetros de ruta en Express. La opción a) utiliza el símbolo '*' en lugar del símbolo ':', que no es válido para declarar parámetros. La opción b) utiliza el símbolo '<>' en lugar del símbolo ':', que también no es válido para declarar parámetros.

#### ¿Qué utilidad nos ayuda a manejar diferentes versiones de Node?

a - npr

b - npx

c - npm

d - nvm

La respuesta correcta es: d) nvm

nvm (Node Version Manager) es una utilidad de línea de comandos que permite instalar y gestionar diferentes versiones de Node.js en un mismo sistema. Esto puede ser muy útil si necesitas trabajar con diferentes proyectos que utilizan versiones diferentes de Node o si quieres probar nuevas características de Node antes de actualizar tu versión principal.

Para instalar y utilizar nvm, primero debes instalarlo en tu sistema utilizando un administrador de paquetes como npm o yarn. Luego, puedes utilizar los comandos de nvm para instalar diferentes versiones de Node y cambiar entre ellas con facilidad.

npm es un administrador de paquetes que se utiliza para instalar y gestionar dependencias de Node.js en un proyecto. npx es una utilidad que viene con npm y que permite ejecutar paquetes npm de manera temporal sin tener que instalarlos de forma permanente en tu proyecto. npr es una opción incorrecta y no existe.

#### ¿Para qué sirve el `event.preventDefault`?

a - Para asegurarnos de que los eventos ejecutan la acción por defecto que les asignó el navegador (en vez de código JS que hayamos escrito por error).

b - Para asegurarnos de que los eventos ejecuten su acción por defecto (por ejemplo, recargar la página al completar un formulario).

c - Para evitar que los eventos ejecuten su acción por defecto (por ejemplo, recargar la página al completar un formulario).

La respuesta correcta es: c) Para evitar que los eventos ejecuten su acción por defecto (por ejemplo, recargar la página al completar un formulario).

El método `preventDefault` es un método de los objetos de eventos de JavaScript que se utiliza para evitar que se ejecute la acción por defecto asociada al evento. Por ejemplo, cuando se completa un formulario HTML, el navegador suele recargar la página por defecto. Si queremos evitar que se recargue la página y en su lugar ejecutar algún otro código JavaScript, podemos utilizar `event.preventDefault` para evitar que se recargue la página.

Por ejemplo:

Copy code

`form.addEventListener('submit', function(event) {   event.preventDefault();   // Código para procesar el formulario en lugar de recargar la página });`

Es importante tener en cuenta que `preventDefault` solo se aplica a eventos que tengan una acción por defecto asociada. Algunos eventos, como los eventos de clic, no tienen una acción por defecto y por lo tanto no se pueden cancelar con `preventDefault`.

#### Si en el .gitignore agrego esto: images/*.js. ¿Cuál de los siguientes archivos sería ignorado?

a - images/jquery.js

b - javascript/jquery.js

c - images/jquery.jpg

d - images/java.jsp

La respuesta correcta es: a) images/jquery.js

El archivo .gitignore se utiliza para especificar qué archivos o directorios deben ignorarse por Git durante el proceso de control de versiones. Los patrones especificados en el archivo .gitignore se aplican a todos los archivos y subdirectorios del directorio donde se encuentra el archivo.

Si agregas la línea `images/*.js` al archivo .gitignore, estarás ignorando todos los archivos con la extensión '.js' que se encuentren en el directorio 'images'. Esto significa que el archivo 'images/jquery.js' sería ignorado, pero los demás archivos no serían ignorados.

En cambio, los archivos 'javascript/jquery.js', 'images/jquery.jpg' y 'images/java.jsp' no serían ignorados ya que no cumplen con el patrón especificado en el .gitignore.

#### ¿Cómo se le llama a la función que se ejecuta cuando termina otra función asíncrona?

a - try catch

b - Función asíncrona

c - Respuesta

d - Callback

La respuesta correcta es: d) Callback

Una función callback es una función que se pasa como argumento a otra función y se ejecuta cuando se completa una tarea asíncrona. Las funciones asíncronas son aquellas que no bloquean la ejecución del programa mientras se ejecutan, sino que permiten que el programa siga ejecutándose mientras la tarea asíncrona se completa en segundo plano.

Por ejemplo, si queremos realizar una solicitud HTTP a un servidor y esperar a que la respuesta esté disponible antes de continuar con la ejecución del programa, podemos utilizar una función callback para manejar la respuesta del servidor una vez que esté disponible.

Copy code

`function getData(callback) {   // Realizar solicitud HTTP a un servidor   // ...   // Ejecutar la función callback cuando se complete la solicitud   callback(data); }  // Llamar a la función getData y proporcionar una función callback para manejar la respuesta getData(function(data) {   console.log(data); });`

En este ejemplo, la función callback se ejecutará cuando se complete la solicitud HTTP y la respuesta esté disponible. La opción a) try catch se refiere a una estructura de control de flujo utilizada para manejar errores, la opción b) Función asíncrona se refiere al tipo de función que utiliza una función callback y la opción c) respuesta es un término genérico que puede referirse a cualquier tipo de resultado o respuesta.

#### ¿Correr la forma de sync de Sequelize es recomendado para producción?

a - Falso

b - Verdadero

La respuesta correcta es: a) Falso

Sequelize es un marco de base de datos de JavaScript que se utiliza para conectarse y realizar operaciones en bases de datos MySQL, MariaDB, SQLite o PostgreSQL. Sequelize proporciona una forma de sincronización de bases de datos que permite crear y modificar la estructura de la base de datos para que coincida con el modelo de datos de la aplicación.

La forma sincrónica de Sequelize se utiliza principalmente durante el desarrollo y se ejecuta de manera sincrónica, lo que significa que bloquea la ejecución del programa hasta que se complete la sincronización. Esto puede ser útil durante el desarrollo para asegurarse de que la base de datos esté siempre en un estado esperado, pero no es recomendado para usar en producción debido a que puede afectar el rendimiento y la escalabilidad de la aplicación.

En lugar de utilizar la forma sincrónica de Sequelize en producción, es mejor utilizar la forma asincrónica, que permite realizar la sincronización de forma asíncrona y no bloqueante

#### Por defecto, ¿cómo detectamos que un fichero se ha escrito con fs.writeFile?

a - El método es síncrono

b - Con una promesa

c - Con el callback

d - No podemos saberlo

La respuesta correcta es: c) Con el callback

El método `fs.writeFile` de Node.js se utiliza para escribir datos en un archivo de forma asíncrona. Por defecto, el método no espera a que se complete la escritura del archivo y en su lugar proporciona una forma de manejar el resultado de la escritura mediante un callback.

Por ejemplo:

Copy code

`const fs = require('fs');  fs.writeFile('message.txt', 'Hello, world!', function(error) {   if (error) {     console.error(error);   } else {     console.log('Escritura del archivo completada');   } });`

En este ejemplo, estamos escribiendo el texto 'Hello, world!' en el archivo 'message.txt'. Una vez que se complete la escritura del archivo, se ejecutará el callback proporcionado y podremos manejar cualquier error que haya ocurrido o mostrar un mensaje de éxito.

Las otras opciones no son correctas. La opción a) síncrono se refiere a un tipo de ejecución que bloquea la ejecución del programa hasta que se complete la tarea, mientras que `fs.writeFile` es asíncrono. La opción b) promesa se refiere a un tipo de objeto utilizado para manejar resultados de forma asíncrona, pero no es la forma predeterminada de manejar el resultado de `fs.writeFile`. La opción d) no podemos saberlo es incorrecta ya que podemos proporcionar un callback para manejar el resultado de la escritura del archivo.

#### Para que dos personas trabajen en paralelo sobre el mismo archivo se recomienda:

a - Un repositorio local por cada uno al que se le hace merge en local y luego un solo computador que haga push a master.

b - Un software externo de gestión de proyectos.

c - Una coordinación previa por videollamada para entender a quién le toca usar master y quién debe esperar.

d - Una rama independiente por cada persona y sus cambios que luego con verificación se hace merge a master.

La respuesta correcta es: d) Una rama independiente por cada persona y sus cambios que luego con verificación se hace merge a master.

Cuando dos personas trabajan en el mismo archivo y utilizan Git para el control de versiones, es importante asegurarse de que los cambios de cada persona no entren en conflicto. Una manera de hacerlo es utilizando ramas (branches en inglés). Cada persona puede crear su propia rama y realizar sus cambios en ella, luego hacer un merge (fusión) de la rama a la rama principal (llamada master) una vez que los cambios estén listos para ser compartidos.

Por ejemplo:

1.  Persona 1 crea una rama llamada 'feature-a' y hace sus cambios en esa rama.
2.  Persona 2 crea una rama llamada 'feature-b' y hace sus cambios en esa rama.
3.  Persona 1 hace un merge de 'feature-a' a master.
4.  Persona 2 hace un merge de 'feature-b' a master.

De esta manera, cada persona puede trabajar de manera independiente en su propia rama sin tener que preocuparse por conflictos con los cambios de la otra persona. Una vez que los cambios estén listos para ser compartidos, se pueden fusionar a la rama master con verificación previa.

Las otras opciones no son recomendables. La opción a) un repositorio local por cada uno al que se le hace merge en local y luego un solo computador que haga push a master implica tener que fusionar los cambios de cada persona de manera manual y puede ser complicado de coordinar. La opción b) un software externo de gestión de proyectos puede ser útil para coordinar el trabajo en general, pero no es necesario para evitar conflictos al trabajar en el mismo archivo. La opción c) una coordinación previa por videollamada para entender a quién le toca usar master y quién debe esperar es ineficiente y puede llevar

#### Cuando usas git stash, los cambios que “guardas” temporalmente se guardan en:

a - Repositorio remoto, en una rama nueva “stash”.

b - Disco duro, en un nuevo commit.

c - Repositorio local, en una rama nueva “stash”.

d - Memoria temporal, volviendo al estado del último commit.

#### ¿Cuál es la forma correcta de trabajar con números mayores que 2^53 gracias a la característica de BigInt que trajo ECMAScript 11?

a - Agregando una "n" al final del número

b - Creando una variable de tipo BigInt

**c - Usando el objeto BigInt pasando el número como parámetro**

La respuesta correcta es: c) Usando el objeto BigInt pasando el número como parámetro.

ECMAScript 11 (también conocido como ECMAScript 2020) introdujo una nueva característica llamada BigInt, que permite trabajar con números enteros de cualquier tamaño. Los números BigInt se diferencian de los números normales (llamados números de punto flotante) en que pueden representar números mayores que 2^53, que es el límite de los números de punto flotante.

Para trabajar con números BigInt, podemos usar el objeto BigInt y pasar el número como parámetro:

Copy code

`const bigNumber = BigInt(123456789012345678901234567890); console.log(bigNumber);  // 123456789012345678901234567890n`

Otra forma de crear un número BigInt es agregando una "n" al final del número:

Copy code

`const bigNumber = 123456789012345678901234567890n; console.log(bigNumber);  // 123456789012345678901234567890n`

La opción b) creando una variable de tipo BigInt es incorrecta ya que no existe un tipo de variable específico para BigInt. Todos los números BigInt son objetos y se crean usando el objeto Big

#### ¿Qué herramienta de React nos permite compartir un estado con todos los componentes de la aplicación?

a - React.useState

b - React.useEffect

c - React.Context

La respuesta correcta es: c) React.Context.

React.Context es una herramienta de React que nos permite compartir un estado con todos los componentes de la aplicación. Esto es útil cuando necesitamos acceder al mismo estado en varios componentes y no queremos tener que pasarlo como propiedad (props) a través de toda la jerarquía de componentes.

Para usar React.Context, primero debemos crear un Context con `React.createContext`, luego proporcionar el valor del contexto a los componentes que lo necesitan con `React.useContext`.

```js
// Crear el contexto
const MyContext = React.createContext();

// Proporcionar el contexto a los componentes que lo necesitan
function App() {
  const value = { foo: 'bar' };
  return (
    <MyContext.Provider value={value}>
      <MyComponent />
    </MyContext.Provider>
  );
}

// Acceder al valor del contexto en un componente
function MyComponent() {
  const contextValue = React.useContext(MyContext);
  console.log(contextValue);  // { foo: 'bar' }
  return <div>{contextValue.foo}</div>;
}
```

La opción a) React.useState y la opción b) React.useEffect son herramientas de React que se utilizan para gestionar el estado en componentes individuales, pero no permiten compartir el estado con otros componentes.

#### ¿Qué herramienta de JavaScript nos permite crear un elemento HTML de tipo img?

a - document.appendChild('img')

b - document.createElement('img')

c - document.querySelector('img')

d - document.getElementById('img')

La respuesta correcta es: b) document.createElement('img').

La función `document.createElement` de JavaScript nos permite crear un elemento HTML de cualquier tipo. Para crear un elemento de tipo `img`, debemos pasar 'img' como parámetro:

Copy code

`const imgElement = document.createElement('img');`

Una vez que hemos creado el elemento, podemos establecer sus atributos y agregarlo al documento. Por ejemplo, podemos establecer la ruta de la imagen con el atributo `src` y agregar el elemento a un elemento padre con `appendChild`:

Copy code

`imgElement.src = 'https://example.com/image.jpg'; document.body.appendChild(imgElement);`

La opción a) document.appendChild('img') es incorrecta ya que `appendChild` espera un elemento como parámetro, no una cadena de texto. La opción c) document.querySelector('img') es incorrecta ya que `querySelector` nos permite seleccionar un elemento del documento, no crear uno nuevo. La opción d) document.getElementById('img') es incorrecta ya que `getElementById` nos permite seleccionar un elemento del documento por su ID, no crear uno nuevo.

#### ¿Cómo accedemos a una variable de entorno llamada NOMBRE?

**a - process.env.NOMBRE**

b - process.NOMBRE

c - env.NOMBRE

d - NOMBRE

#### La definición de "cascada" significa que:

a - El orden de las reglas en CSS NO importa.

**b - El orden de las reglas en CSS importa.**

#### ¿Para qué nos sirve xhttp.status === 200?

**a - Verificamos que el estatus de la petición HTTP resuelva el estado 200.**

b - Verificamos que el estatus de la petición HTTP resuelva el estado 400.

c - Verificamos que el estatus de la petición XHTTPS resuelva el estado 200.

d - Verificamos que el estatus de la petición HTTP resuelva el estado 300.

La respuesta correcta es: a) Verificamos que el estatus de la petición HTTP resuelva el estado 200.

El objeto `xhttp` es una instancia de la clase XMLHttpRequest, que nos permite realizar solicitudes HTTP asíncronas desde JavaScript. Una vez que se ha realizado una solicitud con `xhttp`, podemos acceder al estatus de la petición a través de la propiedad `status`.

La propiedad `status` nos devuelve el código de estatus de la respuesta HTTP, que nos indica el resultado de la solicitud. Por ejemplo, si el estatus es 200, significa que la solicitud se ha completado correctamente.

Por lo tanto, la expresión `xhttp.status === 200` nos permite verificar si la petición HTTP se ha completado correctamente. Si es así, podemos continuar procesando la respuesta. Si no, podemos mostrar un mensaje de error o tomar otras medidas.

`if (xhttp.status === 200) {   // La petición se ha completado correctamente   // Procesamos la respuesta } else {   // Ha habido un error en la petición   // Mostramos un mensaje de error o tomamos otras medidas }`

La opción b) Verificamos que el estatus de la petición HTTP resuelva el estado 400 es incorrecta ya que el estatus 400 indica un error de cliente (por ejemplo

#### ¿Para qué sirven los Alias en Webpack?

a - Para habilitar el "modo incógnito" en el navegador interno de Webpack y hacer nuestras pruebas sin problemas de caché.

**b - Para identificar más fácilmente el "path" de los archivos con los que trabajamos en el proyecto.**

c - Para ocultar la identidad de los programadores cuando hacemos proyectos freelance.

La respuesta correcta es: b) Para identificar más fácilmente el "path" de los archivos con los que trabajamos en el proyecto.

En Webpack, los alias nos permiten establecer nombres cortos para rutas de archivos o directorios que utilizamos con frecuencia en nuestro proyecto. De esta manera, podemos hacer referencia a estas rutas de manera más sencilla y legible en nuestro código.

Por ejemplo, si tenemos un directorio llamado `src/components` que contiene nuestros componentes de React, podemos establecer un alias llamado `@components` para hacer referencia a este directorio:

`module.exports = {   // ...   resolve: {     alias: {       '@components': path.resolve(__dirname, 'src/components'),     },   },   // ... };`

Luego, podemos utilizar el alias `@components` en lugar de la ruta completa en nuestro código:

`import Component from '@components/Component';`

Los alias nos facilitan la lectura y la escritura del código, especialmente cuando trabajamos con rutas largas o complejas. Además, nos permiten cambiar la estructura del proyecto sin tener que actualizar todas las referencias a las rutas.

La opción a) Para habilitar el "modo incógnito" en el navegador interno de Webpack y hacer nuestras pruebas sin problemas de caché es incorrecta ya que Webpack no tiene un navegador interno y los alias no tienen relación con el modo incógnito o el caché. La opción c) Para ocultar la identidad de los programadores cuando hacemos proyectos freelance es incorrecta ya que los alias no tienen relación con la identidad de los programadores.

#### ¿Cuál es el alias de 'npm run start'?

a - `start`

b - `npm start`

c - `npm install start`

d - `npm run start`

#### ¿Qué comando nos ayuda consultar la disponibilidad de un equipo en una red?

**a - ping**

b - ifconfig

c - traceroute

d - whois

#### La shell o línea de comandos es:

a - Una herramienta para codificar comandos de Linux.

b - Un programa que nos ayuda a comunicarnos con nuestro sistema operativo.

c - Una interfaz gráfica que nos permite escribir en ella.

d - Una herramienta para visualizar archivos.