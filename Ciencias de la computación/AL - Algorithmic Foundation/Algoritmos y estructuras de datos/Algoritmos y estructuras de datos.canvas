{
	"nodes":[
		{"type":"group","id":"798e56f5840ee005","x":1920,"y":4040,"width":920,"height":1240,"color":"3","label":"Cálculo de predicados"},
		{"type":"group","id":"487eee2907c5d969","x":2700,"y":600,"width":1340,"height":760,"color":"3","label":"Estructuras de Datos"},
		{"type":"group","id":"44a49d2483e92c61","x":2700,"y":1440,"width":1340,"height":712,"color":"4","label":"Estrategias conocidas de resolución de problemas"},
		{"type":"group","id":"64a2fdaf3b73b0b3","x":2700,"y":-120,"width":1340,"height":620,"color":"1","label":"Analisis de algoritmos"},
		{"type":"group","id":"e50845b32cbca552","x":600,"y":1720,"width":640,"height":1014,"color":"4","label":"Semántica de la lógica proposicional\n"},
		{"type":"group","id":"f497e570a02e0d73","x":2840,"y":5480,"width":820,"height":1259,"color":"5","label":"Especificaciones"},
		{"type":"group","id":"5ec5633dae4fe0ce","x":1240,"y":2880,"width":680,"height":1000,"color":"2","label":"Cálculo proposicional"},
		{"type":"group","id":"b8ba1eb4e3593130","x":-120,"y":700,"width":720,"height":860,"color":"#5c2e85","label":"Introducción a la programacion funcional"},
		{"type":"group","id":"e3b09de695e971be","x":-660,"y":-220,"width":540,"height":780,"color":"6","label":"Introducción"},
		{"type":"text","text":"# Introducción a los algoritmos","id":"48fd14dbaa2280fa","x":-660,"y":-400,"width":540,"height":80,"color":"1"},
		{"type":"text","text":"- Historia de la Computación. Software libre. Introducción a la metodología de trabajo con expresiones aritméticas. Precedencia y tipado. Validez y satisfacibilidad. Funciones.","id":"509ee29686a8ca93","x":-640,"y":-200,"width":500,"height":140},
		{"type":"text","text":"Formalismo básico. Números naturales. Tuplas. Listas, constructores y operadores, propiedades. Modelo computacional. Diseño de programas recursivos. Demostraciones por inducción.","id":"809df64ca6ce213d","x":-100,"y":720,"width":680,"height":100},
		{"type":"text","text":"Estructura de las pruebas formales. Axioma y teoremas. Propiedades de la lógica proposicional. Demostraciones: Equivalencia, disyunción, conjunción, implicación, negación, discrepancia.","id":"57b9b70c3d3795fb","x":1260,"y":2900,"width":640,"height":99},
		{"type":"text","text":"Noción de predicado. Cuantificador universal. Cuantificador existencial. Enfoque semántico (interpretación) y enfoque sintáctico (leyes). Demostraciones.","id":"27827d7ac63ea2e4","x":1940,"y":4068,"width":880,"height":92},
		{"type":"text","text":"Representación del conocimiento en lógica de predicados. Concepto de especificación formal de un problema. Ejemplos y resolución de problemas.","id":"adfb9ae914de64fc","x":2860,"y":5500,"width":780,"height":83},
		{"type":"text","text":"BIBLIOGRAFÍA BÁSICA \n- Cálculo de Programas, J. Blanco, D. Barsotti, S. Smith, 2009. \n- Discrete Mathematics Using a Computer, John O'Donnell, Cordelia Hall and Rex Page. 2nd Edition, Published by Springer, 2006. \n\nBIBLIOGRAFÍA COMPLEMENTARIA \n- Material de Estudio. Acosta, Cherini, Losano, Pagano, 2014.","id":"737a75af0f7f5f91","x":20,"y":-400,"width":620,"height":300},
		{"type":"text","text":"Operadores Booleanos. Tablas de Verdad. Equivalencia, disyunción, conjunción, implicación, negación, discrepancia. Representación del conocimiento en lógica proposicional. Introducción al análisis de razonamientos.","id":"7c7ed388363b32b2","x":620,"y":1740,"width":600,"height":140},
		{"type":"text","text":"# Algoritmos y estructuras de datos","id":"3b5b44ed9205e00f","x":2693,"y":-303,"width":607,"height":83},
		{"type":"text","text":"Recurrencias Recurrencias divide y vencerás. Formulación y resolución. Ejemplos. Demostración de la resolución de recurrencias divide y vencerás.","id":"a8d087cc6ca973ef","x":2720,"y":420,"width":1300,"height":60},
		{"type":"text","text":"Motivación Problema de Ordenación. Diferentes maneras de ordenar. Ordenación por selección. El ciclo for. Conteo de operaciones de un programa. Esquemas de conteo. Conteo de comparaciones de la ordenación por selección. Incidencia del crecimiento del tamaño de los datos en la performance del algoritmo. Introducción del término “del orden de”. Ordenación por inserción. Conteo. Peor caso, mejor caso y caso medio.","id":"4bbb681886ab5d1b","x":2720,"y":-100,"width":1300,"height":100},
		{"type":"text","text":"La notación Ο Significado de peor caso y caso medio. Operaciones elementales. Análisis aproximado. La notación Ο. Ejemplos. Insignificancia de las constantes aditivas y multiplicativas. Reflexividad y transitividad. Igualdad entre los O's de funciones. Equivalencia entre logaritmos de diferente base. Regla del límite. Jerarquía: logaritmos, polinomios, exponenciales, factoriales. El O de la suma y el producto. El O de un polinomio. Terminología: funciones y algoritmos logarítmicos, cuadráticos, cúbicos, polinomiales, exponenciales. Balance entre tiempo y espacio de los algoritmos.","id":"667f07f2f00077d2","x":2720,"y":20,"width":1300,"height":156},
		{"type":"text","text":"Ejemplos Búsqueda lineal. Análisis de mejor caso, peor caso y caso medio. Búsqueda lineal en un arreglo ordenado. Análisis de mejor caso, peor caso y caso medio. Búsqueda binaria. Análisis de mejor caso, peor caso y caso medio. Contraste entre el algoritmo lineal y el logarítmico cuando el tamaño de la entrada crece.","id":"1ab8a5707725fab6","x":2720,"y":194,"width":1300,"height":106},
		{"type":"text","text":"Motivación de la recurrencias Transformación gradual de la ordenación por selección en la ordenación por intercalación. Versión funcional de la ordenación por intercalación. Versión imperativa. Análisis de la ordenación por intercalación. Resolución de la recurrencia.","id":"068d6bfe72d57a4b","x":2720,"y":320,"width":1300,"height":71},
		{"type":"text","text":"Introducción Importancia de la elección de estructuras de datos adecuadas. Los tipos concretos como concepto relativo a un lenguaje de programación. Los tipos abstractos como concepto asociado a un problema que se quiere resolver. Tipos abstractos y sus diferentes representaciones.","id":"12177fcf0848d8d0","x":2720,"y":620,"width":1300,"height":105},
		{"type":"text","text":"Estructuras concretas Estructuras concretas más comunes en los lenguajes de programación. Arreglos. Operaciones para manipularlos. Almacenamiento en memoria. Representación gráfica. Eficiencia de las operaciones. Diferentes tipos de índices. Tipos enumerados. Ciclo for generalizado. Listas como tipos concretos. Operaciones para manipularlos. Almacenamiento en memoria. Representación gráfica. Eficiencia de las operaciones. Registros. Operaciones para manipularlos. Almacenamiento en memoria. Representación gráfica. Problema de aliasing.","id":"e1bbc652d5872596","x":2720,"y":746,"width":1300,"height":134},
		{"type":"text","text":"Tipos abstractos de datos (TAD's) Tipos abstractos más usuales. Tipos abstractos como concepto que surge de un problema a resolver. Chequeo de paréntesis balanceados: TAD Contador, operaciones, ecuaciones. Chequeo de delimitadores balanceados: TAD Pila, operaciones, ecuaciones. Representaciones posibles de contadores. Ejemplo: versión iterativa de la ordenación por intercalación usando una pila. Ejemplo: evaluación de expresiones en notación polaca inversa usando una pila. TAD Lista. Operaciones. Ecuaciones. Representaciones usando arreglos. Representaciones de pilas usando arreglos y listas. Transmisión de datos: TAD cola, operaciones, ecuaciones. Representaciones usando arreglos y listas. Listas enlazadas. Representación gráfica. Representaciones de listas, pilas y colas usando listas enlazadas, listas enlazadas con puntero al último y listas circulares. Aliasing y errores usuales al programar con punteros. Manejo de memoria en ejecución. Diccionarios: TAD árbol binario. Representación gráfica. Operaciones. Ecuaciones. Terminología botánica y genealógica. Posiciones. Subárbol correspondiente a una posición. Posiciones de un árbol. Elemento alojado en una posición de un árbol. Representación usando punteros. Árboles binario de búsqueda (ABB). Operaciones: versiones recursiva e iterativa. Eficiencia. TAD cola de prioridades. Operaciones. Ecuaciones. Heap. Implementación de cola de prioridades usando un heap. Eficiencia de las operaciones. Heap usando arreglos. Eficiencia. Ordenación con heap. Eficiencia. Ordenación con heap sin arreglo auxiliar.","id":"7c65c9296cc7854c","x":2720,"y":896,"width":1300,"height":364},
		{"type":"text","text":"Otras estructuras Problema unión-find. Inicialización virtual.","id":"b478674968208bec","x":2720,"y":1280,"width":1300,"height":50},
		{"type":"text","text":"Uso de heurísticas en algoritmos. Estrategias de diseño de algoritmos.","id":"324501f3f3a111c5","x":2720,"y":1473,"width":1300,"height":59},
		{"type":"text","text":"Algoritmos voraces Propiedades generales de los algoritmos voraces (o greedy o glotones o golosos). Esquema general. Problema de la moneda simplificado. Problema de la mochila simplificado. Problema del camino de costo mínimo. Algoritmo de Dijkstra. Problema del árbol generador de costo mínimo. Algoritmos de Prim y de Kruskal.","id":"c99b1e4e69485686","x":2720,"y":1552,"width":1300,"height":106},
		{"type":"text","text":"Divide y vencerás Propiedades generales de la técnica divide y vencerás. Esquema general. Búsqueda binaria. Ordenación por intercalación. Ordenación rápida (quicksort). Cálculo eficiente de la potencia n-ésima de un número. Multiplicación de grandes números.","id":"8728305aa299f364","x":2720,"y":1675,"width":1300,"height":77},
		{"type":"text","text":"Backtracking Motivación: algoritmo para salir de un laberinto. Problema de la moneda. Problema de la mochila. Problema de los caminos de costo mínimo.","id":"69204a2da850686a","x":2720,"y":1775,"width":1300,"height":77},
		{"type":"text","text":"Programación dinámica Funciones recursivas potencialmente exponenciales. Confección de tablas. Fibonacci. Problema de la moneda. Problema de la mochila. Funciones con memoria. Revisión de los problemas de la moneda y de la mochila. Problema de los caminos de costo mínimo. Algoritmo de Floyd. Cómputo de números combinatorios. Reducción del espacio necesario para las tablas.","id":"a2c0785b7e3d2120","x":2720,"y":1872,"width":1300,"height":94},
		{"type":"text","text":"Recorrida de grafos y más backtracking Recorrida de árboles binarios. Pre-orden, in-orden y pos-orden de izquierda a derecha y de derecha a izquierda. In-orden para listar ordenadamente un ABB. Recorrida de árboles finitarios. Precondicionamiento. Pre-orden y pos-orden para resolver el problema del ancestro. Recorrida de árboles dirigidos o no. DFS recursivo e iterativo con pila. BFS con cola. Grafos implícitos. Problema de las ocho reinas. Podas graduales al grafo de búsqueda.","id":"215a2c1fdf65cf93","x":2720,"y":1992,"width":1300,"height":138},
		{"type":"text","text":"BIBLIOGRAFÍA BÁSICA \n- Fundamentos de Algoritmia, Gilles Brassard, Paul Bratley. Prentice-Hall, 1997. \n- Fundamentals of Algorithmics. Gilles Brassard, Paul Bratley. Prentice-Hall, 1995. \n- Introduction to Algorithms. Thomas Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. Cambridge, 2009.\n- Introduction to Algorithms: A Creative Approach. Udi Manber. Addison-Wesley, 1989. \n\nBIBLIOGRAFÍA COMPLEMENTARIA \n- Programación Metódica. José Luis Balcázar. McGraw-Hill, 1993. \n- Matemática Discreta. Norman L. Biggs. Vives V., 1998 \n- Cálculo de Programas. Javier Blanco, Silvina Smith, Damián Barsotti. Universidad Nacional de Córdoba, 2008. \n- Programming: the Derivation of Algorithms. Anne Kaldewaij. Prentice-Hall, 1990.","id":"62a4ab0d62dbca4a","x":4080,"y":698,"width":717,"height":562}
	],
	"edges":[
		{"id":"d54fca477aec33e5","fromNode":"48fd14dbaa2280fa","fromSide":"bottom","toNode":"e3b09de695e971be","toSide":"top","color":"1"},
		{"id":"c53b1bc9958f13a2","fromNode":"e3b09de695e971be","fromSide":"bottom","toNode":"b8ba1eb4e3593130","toSide":"left","color":"6"},
		{"id":"59609d629ed8da6c","fromNode":"b8ba1eb4e3593130","fromSide":"bottom","toNode":"e50845b32cbca552","toSide":"left","color":"#5c2e85"},
		{"id":"d640197eb446ab19","fromNode":"e50845b32cbca552","fromSide":"bottom","toNode":"5ec5633dae4fe0ce","toSide":"left","color":"4"},
		{"id":"cea36db0182cf853","fromNode":"5ec5633dae4fe0ce","fromSide":"bottom","toNode":"798e56f5840ee005","toSide":"left","color":"2"},
		{"id":"c4582dd048597918","fromNode":"798e56f5840ee005","fromSide":"bottom","toNode":"f497e570a02e0d73","toSide":"left","color":"3"}
	]
}