##### CS Core:
1. Imperative programming as a sunset if object-oriented programming
2. Object-oriented design
	a. Decomposition into objects carrying state and having behavior
	b. Class-hierarchy design for modeling
3. Definition of classes: fields, methods, and constructors (See also: SDFFundamentals)
4. Subclasses, inheritance (including multiple inheritance), and method overriding
5. Dynamic dispatch: definition of method-call
6. Exception handling (See also: PDC-Coordination, SF-System-Reliability)
7. Object-oriented idioms for encapsulation
	a. Privacy, data hiding, and visibility of class members
	b. Interfaces revealing only method signatures
	c. Abstract base classes, traits and mixins
8. Dynamic vs static properties
9. Composition vs inheritance
10. Subtyping
	a. Subtype polymorphism; implicit upcasts in typed languages
	b. Notion of behavioral replacement: subtypes acting like supertypes
	c. Relationship between subtyping and inheritance

##### KA Core:
11. Collection classes, iterators, and other common library components

#### Illustrative Learning Outcomes:
##### CS Core:
1. Enumerate the difference between the imperative and object-oriented programming paradigms.
2. Compose a class through design, implementation, and testing to meet behavioral requirements.
3. Build a simple class hierarchy utilizing subclassing that allows code to be reused for distinct subclasses.
4. Predict and validate control flow in a program using dynamic dispatch.
5. Compare and contrast:
	c. the procedural/functional approach-defining a function for each operation with the function body providing a case for each data variant-and 
	d. the object-oriented approach-defining a class for each data variant with the class
	definition providing a method for each operation.
	e. Understand both as defining a matrix of operations and variants. (See also: FPLFunctional)
6. Compare and contrast the benefits and costs/impact of using inheritance (subclasses) and composition (in particular how to base composition on higher order functions).
7. Explain the relationship between object-oriented inheritance (code-sharing and overriding) and subtyping (the idea of a subtype being usable in a context that expects the supertype).
8. Use object-oriented encapsulation mechanisms such as interfaces and private members.
9. Define and use iterators and other operations on aggregates, including operations that take functions as arguments, in multiple programming languages, selecting the most natural idioms for each language. (See also: FPL-Functional)
##### KA Core:
10. Use collection classes and iterators effectively to solve a problem.