## Separadores numÃ©ricos

Los separadores numÃ©ricos ayudan a la legibilidad de cantidades con varias cifras. Se utiliza el caracter guion bajo (Â `_`Â ) paraÂ **separar las cifras**, y no afecta a la ejecuciÃ³n del programa.

Lo ideal es separar cada 3 cifras, para visualizar los miles, millones, billones, etc.

```js
// ğŸ”½ Baja legibilidad
const numero1 = 3501548945
console.log( numero1 ) // 3501548945

// âœ… Alta legibilidad
const numero2 = 3_501_548_945
console.log( numero1 ) // 3501548945
```

De esta manera puedes identificar el nÃºmero rÃ¡pidamente.

## MÃ©todo replaceAll

El mÃ©todoÂ `replaceAll`Â retorna un nuevoÂ _string_, reemplazandoÂ **todos los elementos por otro**.

Este mÃ©todo recibe dos argumentos:

-   ElÂ **patrÃ³n a reemplazar**, puede ser unÂ _string_Â o una expresiÃ³n regular.
-   ElÂ **nuevo elemento**Â que sustituye al reemplazado.

Este procedimiento fue creado para solucionar el problema que tenÃ­a el mÃ©todoÂ `replace`, que realizaba la misma funciÃ³n de reemplazar elementos, pero solamenteÂ **una sola vez**Â por invocaciÃ³n.

```js
const mensaje = "JavaScript es maravilloso, con JavaScript puedo crear el futuro de la web."

mensaje.replace("JavaScript", "Python")
// 'Python es maravilloso, con JavaScript puedo crear el futuro de la web.'

mensaje.replaceAll("JavaScript", "Python")
// 'Python es maravilloso, con Python puedo crear el futuro de la web.'

mensaje.replaceAll(/a/g, "*")
// 'J*v*Script es m*r*villoso, con J*v*Script puedo cre*r el futuro de l* web.'
```

## MÃ©todos privados de clases

Los mÃ©todos privados consiste enÂ **limitar el acceso a propiedades y mÃ©todos**Â agregando el caracter numeral (Â `#`). Por defecto, las propiedades y mÃ©todos de una clase en JavaScript son pÃºblicas, es decir, se puede acceder a ellos fuera de la clase.

```js
class Clase {
  #private(valor){
    console.log(valor)
  }
  
  public(valor){
    console.log(valor)
  }
}

const clase = new Clase()
clase.public("Hola")  // 'Hola'
clase.private("Hola") // TypeError: clase.private is not a function
```

## Promise.any

`Promise.any()`Â es otra forma de manejar varias promesas, queÂ **retornarÃ¡ la primera promesa que sea resuelta**Â y rebotarÃ¡ si todas las promesas son rechazadas.

```js
const promesa1 = Promise.reject("Ups promesa 1 fallÃ³")
const promesa2 = Promise.reject("Ups promesa 2 fallÃ³")
const promesa3 = Promise.resolve("Promesa 3")


Promise.any([promesa1, promesa2, promesa3])
    .then(respuesta => console.log(respuesta)) // Promise 3
    .catch(error => console.log(error))
```

## AggregateError

La forma de rechazar promesas de Promise.any() es retornando un **AggregateError**: un nuevo objeto compuesto por diversos errores con las propiedades name y message.


## WeakRef

Â¿Has leÃ­do alguna vez la expresiÃ³nÂ _hereâ€™s where Javascript gets weird_? AllÃ¡ vamos.

El recolector de basura oÂ _garbage collector_Â de JavascriptÂ **elimina de la memoria las referencias innecesarias**Â durante el transcurso de una aplicaciÃ³n, como es el caso de aquellas variables que han quedado inaccesibles.

El objeto globalÂ 

WeakRef

Â (en referencia aÂ _Weak References_) establece unaÂ _referencia dÃ©bil_Â hacia otro objeto, lo que permitirÃ­a optimizar el uso de memoria gracias a un control del recolector de basura,Â **que verÃ¡ esta referencia desprotegida**Â y podrÃ¡ eliminarla reclamando asÃ­ la memoria correspondiente.

Podemos entonces diferenciar desde ahora dos tipos de referencias: las clÃ¡sicas sÃ³lidas (propiedades, variablesâ€¦) y las dÃ©biles, establecidas por este objeto, que abren la puerta aÂ **almacenar objetos voluminosos de los que poder prescindir una vez no sean necesarios para la ejecuciÃ³n del programa**.

Se vale de un Ãºnico mÃ©todoÂ 

.deref(),

Â que recuperarÃ­a la referencia si aÃºn sigue disponible.

Este ejemplo, a efectos clarificadores, crea una referencia dÃ©bil hacia un objeto del DOM, permitiendo que sea eliminada cuando ya no sea necesario:

````js
class Counter {
  constructor(domElement) {
    this.ref = new WeakRef(domElement); // Referencia de forma dÃ©bil el objeto
    this.start();
  }

  start() {
    this.count = 0;
    this.timer = setInterval(tick, 1000);
  }

  stop() {
    clearInterval(this.timer);
    this.timer = 0;
  }

  thick() {
    const element = this.ref.deref(); // Si aÃºn existe la referencia, la recupera

    if (element) {
      element.textContent = ++this.count;
    } else {
      this.stop();

      this.ref = null;
    }
  }
}

const counter = new Counter(document.getElementById("counter"));

counter.start();

// Tras 5 segundos, eliminar el objeto del DOM supondrÃ¡ liberarlo de la memoria

setTimeout(() => {
  document.getElementById("counter").remove();
}, 5000);
````

## _Getters y setters_Â privados

Los mÃ©todos de acceso nos permitÃ­an declarar, a travÃ©s de la sintaxisÂ ``get nombrePropiedad()``Â yÂ ``set nombrePropiedad()``, mÃ©todos en una clase con un comportamiento de propiedad a efectos externos:

```js
class Invoice {
  
  /* ... */
  get totalInvoice() {
     return (this.cost + this.benefit) * this.tax
  }
  set tax(value) {
     this.tax = value
  }
}
const invoice = new Invoice()
invoice.tax = .21      // manipularÃ­a el valor de la propiedad en la clase
invoice.totalInvoice   // retornarÃ­a el sumatorio que proceda
```

La novedad de ES12 reside enÂ **limitar el acceso a cualquier mÃ©todo accesorio**Â al prefijarlo con una almohadilla:

```js
class Invoice {
  
  /* ... */
  get #benefit() {
     return 10
  }
}
const invoice = new Invoice()
invoice.benefit   // undefined
```

## Operador de asignaciÃ³n lÃ³gica

El operador de asignaciÃ³n lÃ³gica combina en una expresiÃ³n binaria los operadores lÃ³gicosÂ **&& || ??**Â con una asignaciÃ³n, formalizÃ¡ndola segÃºn la naturalezaÂ _truthy_Â oÂ _falsy_Â del primero de los operandos. 
En el caso deÂ **&&**, la asignaciÃ³n lÃ³gica sÃ³lo se produce frente a un valorÂ _truthy_:
```js
let code = 100
let newCode = 200
code &&= newCode 
console.log(code)     // 200
```

En el caso de **||**, la asignaciÃ³n lÃ³gica sÃ³lo se produce frente a un valor falsy:

```js
let code = 100
let newCode = 200
code ||= newCode 
console.log(code)     // 100
```

En el caso de **??**, la asignaciÃ³n lÃ³gica sÃ³lo se produce frente a un valor **null** o **undefined**, exclusivamente:

```js
let code = undefined
let newCode = 200
code ??= newCode
console.log(code)     // 200
```
