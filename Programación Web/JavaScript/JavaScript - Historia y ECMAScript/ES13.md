El mÃ©todoÂ `at`Â deÂ _arrays_Â sirve paraÂ **acceder a los elementos a partir del Ã­ndice**.

`array.at(Ã­ndice)`

## Ãndices positivos y negativos enÂ _arrays_

Los Ã­ndices positivos comienzan desdeÂ `0`Â hasta la longitud total menos uno, deÂ **izquierda a derecha**Â delÂ _array_. El Ã­ndiceÂ `0`Â es la primera posiciÃ³n.

```js
[0,1,2,3, ...., lenght-1]
```

Los Ã­ndices negativos comienzan desdeÂ `-1`Â hasta el negativo de la longitud total delÂ _array_, deÂ **derecha a izquierda**. El Ã­ndiceÂ `-1`Â es la Ãºltima posiciÃ³n.

```js
[-lenght, ...,  -3, -2, -1]
```

## CÃ³mo utilizar el mÃ©todoÂ `at`

La utilidad mÃ¡s importante de este mÃ©todo es para manejarÂ **Ã­ndices negativos**. Algo que no se puede con la notaciÃ³n de corchetes.

```js
const nombres = ["Andres", "Valeria", "Ana", "Ramiro", "Richard"]

nombres.at(-1) // "Richard"
nombres[-1] // undefined
nombres.at(-3) // "Ana"
nombres[nombres.length -1] // "Richard"
```

Puedes utilizar la notaciÃ³n de corchetes, pero necesitas obtener la longitud delÂ _array_Â y restarle una unidad, generando mucho cÃ³digo que puede volverse difÃ­cil de leer.

```js
nombres[nombres.length -1] // "Richard"
```

## Top level await

Anterior a ECMAScript 13, cuando se introdujo funciones asÃ­ncronas, si utilizabasÂ `await`Â fuera deÂ `async`, existirÃ¡ un error de sintÃ¡xis.

```js
// Error
await fetch(URL)
// SyntaxError: await is only valid in async function
```

Ahora, conÂ _top level await_Â esto es posible, sin ningÃºn error. Esto puede servir paraÂ [importaciones de manera dinÃ¡mica](https://platzi.com/clases/3504-ecmascript-nuevo/51779-dynamic-import/)Â o iniciar la conexiÃ³n de tus bases de datos. Siempre y cuando respetes que debe estar en la parte encima del archivo de tipo mÃ³dulo.

## Logical Assignment Operators `(&&= ||= ??=)`

Los operadores lÃ³gicosÂ `&&`,Â `||`Â yÂ `??`Â ahora tambiÃ©n pueden usarse para asignar valores de una forma mÃ¡s sencilla y corta. Perfecto para asignar valores por defecto a variables.

```javascript
// Si x es falsy, se le asigna y
x ||= y
// Equivale a...
x || (x = y)

// Si x es truthy, se le asigna y
x &&= y
// Equivale a...
x && (x = y)

// Si x es null o undefined, se le asigna y
x ??= y
// Equivale a...
x ?? (x = y)
```

Hay que tener en cuenta que en estas asignaciones, ademÃ¡s, entra el juego la evaluaciÃ³nÂ _short-circui_t. Esto quiere decir que estas asignaciones lÃ³gicas se evaluan de izquierda a derecha.Â **Si una expresiÃ³n lÃ³gica no se cumple, no se evalÃºa la siguiente.**

Esto es importante para no cometer errores:

```javascript
// este nuevo tipo de asignaciÃ³n con &&
x &&= y
// âœ… es equivalente a...
x && (x = y)
// âŒ NO es equivalente a...
x = x && y
// ya que la asignaciÃ³n ocurre siempre independientemente de la evaluaciÃ³n
```

## Numeric Separator

Leer algunas cifras en JavaScript puede ser una tarea difÃ­cil. Para solucionar esto, el nuevo separador numÃ©ricoÂ `_`Â te permite identificar de manera mÃ¡s sencilla cualquier nÃºmero.

```javascript
// Es difÃ­cil saber quÃ© cifra representa
1000000000
19436871.42

// Â¡Con Numeric Separator es mÃ¡s fÃ¡cil!
1_000_000_000 // Ah, es mil millones
100_000_000 // Y esto es cien millones
19_436_871.42 // Â¡De un vistazo!
```

## Promise.any

Â¿Alguna vez has querido esperar una lista de promesas y que, al resolverse correctamente una cualquiera, continuar con la ejecuciÃ³n de tu cÃ³digo? Pues para eso se incorporaÂ **Promise.any()**.

```javascript
const promises = [
  fetch('/from-external-api'),
  fetch('/from-memory'),
  fetch('/from-new-api'),
]

try {
  // espera a la primera respuesta correcta que termine
  const first = await Promise.any(promises)
  // La mÃ¡s rÃ¡pida fue la de memoria
  console.log(first) // respuesta desde 'from-memory'
} catch (error) {
  // Â¡Todas las promesas han fallado!
  console.assert(error instanceof AggregateError)
  // Log the rejection values:
  console.log(error.errors)
  // â†’ [
  //     <TypeError: Failed to fetch /from-external-api>,
  //     <TypeError: Failed to fetch /from-memory>,
  //     <TypeError: Failed to fetch /from-new-api>
  //   ]
}
```

### AggregateError

Como has podido ver en el ejemplo anterior, ahora cuando la promesa falla, se devuelve una instancia deÂ `AggregateError`. Este error es una instancia deÂ `Error`Â y tiene una propiedad llamadaÂ `errors`Â que contiene una lista de errores para cada promesa que fallÃ³.

### La diferencia conÂ `Promise.race`â€¦

`Promise.race`Â yÂ `Promise.any`Â son muy similares. La diferencia es queÂ `Promise.race`Â se resuelve cuando cualquier promesa ha sidoÂ _resuelta_Â oÂ _rechazada_. En cambioÂ `Promise.any`Â ignora las promesas que son rechazadas y sÃ³lo se resuelve cuando se resuelve la primeraâ€¦ o se rechaza cuando todas las promesas se han rechazado.

### La tabla de diferencias deÂ `Promise`

Para que lo veas mÃ¡s claro, he preparado una pequeÃ±a tabla para diferenciar los diferentes mÃ©todos de Promise a la hora de trabajar con un array de promesas, para que eligas la que mÃ¡s encaje con tu caso de uso.

| MÃ©todo             | DescripciÃ³n                                      | AÃ±adida en... |
| ------------------ | ------------------------------------------------ | ------------- |
| Promise.allSettled | Espera a todas las promesas se resuelvan o no    | ES2020        |
| Promise.all        | Se para cuando una promesa es rechazada          | ES2015        |
| Promise.race       | Se para cuando una promesa es rechaza o resuelta | ES2015        |
| Promise.any        | Se para cuando una promesa es resuelta           | ES2021        |

## replaceAll

Hasta ahora, reemplazar todas lasÂ _instancias_Â de una cadena de texto en una cadena de texto te obligaba a usarÂ `Regex`Â ya queÂ `replace`, si le pasabas unÂ _string_, lo que hacÃ­a era sÃ³lo reemplazar la primera instancia encontrada.

```javascript
// Â¡Quiero cambiar las manzanas por bananas!
'ğŸğŸğŸ‹ğŸ‹ğŸŠğŸŠ'.replace('ğŸ', 'ğŸŒ')
// Pero quÃ©...
// -> 'ğŸŒğŸğŸ‹ğŸ‹ğŸŠğŸŠ'

// Â¡Tienes que usar Regex para conseguirlo!
'ğŸğŸğŸ‹ğŸ‹ğŸŠğŸŠ'.replace(/ğŸ/g, 'ğŸŒ')

// Â¡Hasta ahora! Â¡Hola replaceAll!
'ğŸğŸğŸ‹ğŸ‹ğŸŠğŸŠ'.replaceAll('ğŸ', 'ğŸŒ')
```

`replaceAll`Â queda mucho mÃ¡s legible en nuestro cÃ³digo y hace justo lo que esperaba: cambiar todas lasÂ _instancias_Â de una cadena de texto en una cadena de texto.

## WeakRef

`WeakRef`Â te permite crear una referencia dÃ©bil a un objeto para no prevenir que se destruya por elÂ _Garbage Collector_Â de JavaScript. Â¿Por quÃ©? Pues por quÃ© cuando creamos un objeto, especialmente si son grandes, estos no son automÃ¡ticamente destruidos por elÂ _Garbage Collector_Â si existe una referencia a ellos.

Con el mÃ©todoÂ `deref`Â deÂ `WeakRef`, podemos acceder a la referencia del objeto. Si la referencia al objeto ha sido eliminada, se devuelveÂ `undefined`.

```javascript
// Al crear un objeto...
let coords = { x: 13, y: 72 }
// Mientras tengas acceso a Ã©l directamente,
// el objeto no serÃ¡ liberado de memoria
// por el Garbage Collector

// Ahora podemos crear una referencia dÃ©bil al objeto
const weakCoords = new WeakRef(coords)

// Recuperamos las propiedades del elemento
const ref = weakCoords.deref()
if (ref) {
  console.log('TodavÃ­a tenemos acceso a las coordenadas')
  ref.x // -> 13
} else {
  // ref es `undefined`
  console.log('La referencia ha sido eliminada')
}
```

> [!warning] Tener en cuenta
> Una cosa que debes tener en cuenta con WeakRef es queâ€¦ seguramente es mejor si no lo usas. Esta funcionalidad estÃ¡ pensado para casos muy especÃ­ficos que, en general, acabarÃ¡n en librerÃ­as y frameworks. EstÃ¡ bien que conozcas su existencia pero los casos de uso son muy limitados. La recolecciÃ³n de basura en JavaScript puede variar mucho dependiendo del navegador, entorno y especificaciones del sistema.

